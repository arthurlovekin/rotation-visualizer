// Generated by tests/scipy_test_case_generator.py
// Do not edit these tests by hand. Regenerate with:
//   python tests/scipy_test_case_generator.py -o src/app/rotation_tests_generated.rs
//
// This file is included from src/app/rotation.rs via include!().
// Kept in src/app/ (not tests/) so Cargo does not compile it as a separate integration test.

#[cfg(test)]
mod scipy_tests {
    use super::*;

    fn assert_quaternion_near(rust_actual: &Quaternion, scipy_expected: &Quaternion, tol: f32) {
        let q_ok = (rust_actual.w - scipy_expected.w).abs() <= tol
            && (rust_actual.x - scipy_expected.x).abs() <= tol
            && (rust_actual.y - scipy_expected.y).abs() <= tol
            && (rust_actual.z - scipy_expected.z).abs() <= tol;
        let dual_ok = (rust_actual.w + scipy_expected.w).abs() <= tol
            && (rust_actual.x + scipy_expected.x).abs() <= tol
            && (rust_actual.y + scipy_expected.y).abs() <= tol
            && (rust_actual.z + scipy_expected.z).abs() <= tol;
        assert!(
            q_ok || dual_ok,
            "Quaternion: Rust got {:?}, Scipy expected {:?}",
            rust_actual,
            scipy_expected
        );
    }

    fn assert_axis_angle_near(rust_actual: &AxisAngle, scipy_expected: &AxisAngle, tol: f32) {
        let angle_ok = (rust_actual.angle - scipy_expected.angle).abs() <= tol;
        let axis_ok = (rust_actual.x - scipy_expected.x).abs() <= tol
            && (rust_actual.y - scipy_expected.y).abs() <= tol
            && (rust_actual.z - scipy_expected.z).abs() <= tol;
        let equiv_ok = (rust_actual.angle - (2.0 * std::f32::consts::PI - scipy_expected.angle)).abs() <= tol
            && (rust_actual.x + scipy_expected.x).abs() <= tol
            && (rust_actual.y + scipy_expected.y).abs() <= tol
            && (rust_actual.z + scipy_expected.z).abs() <= tol;
        let zero_ok = rust_actual.angle <= tol && scipy_expected.angle <= tol;
        assert!(
            (angle_ok && (axis_ok || zero_ok)) || (equiv_ok && !zero_ok),
            "AxisAngle: Rust got {:?}, Scipy expected {:?}",
            rust_actual,
            scipy_expected
        );
    }

    fn assert_rotation_vector_near(rust_actual: &RotationVector, scipy_expected: &RotationVector, tol: f32) {
        let norm_a = (rust_actual.x * rust_actual.x + rust_actual.y * rust_actual.y + rust_actual.z * rust_actual.z).sqrt();
        let norm_b = (scipy_expected.x * scipy_expected.x + scipy_expected.y * scipy_expected.y + scipy_expected.z * scipy_expected.z).sqrt();
        let zero_ok = norm_a <= tol && norm_b <= tol;
        let vec_ok = (rust_actual.x - scipy_expected.x).abs() <= tol
            && (rust_actual.y - scipy_expected.y).abs() <= tol
            && (rust_actual.z - scipy_expected.z).abs() <= tol;
        // v ≡ -v when |v| = π (rotation of π around axis = rotation of π around -axis)
        let pi = std::f32::consts::PI;
        let near_pi = (norm_a - pi).abs() <= tol && (norm_b - pi).abs() <= tol;
        let vec_neg_ok = near_pi
            && (rust_actual.x + scipy_expected.x).abs() <= tol
            && (rust_actual.y + scipy_expected.y).abs() <= tol
            && (rust_actual.z + scipy_expected.z).abs() <= tol;
        assert!(
            zero_ok || vec_ok || vec_neg_ok,
            "RotationVector: Rust got {:?}, Scipy expected {:?}",
            rust_actual,
            scipy_expected
        );
    }

    fn assert_rotation_matrix_near(rust_actual: &RotationMatrix, scipy_expected: &RotationMatrix, tol: f32) {
        for i in 0..3 {
            for j in 0..3 {
                assert!(
                    (rust_actual[i][j] - scipy_expected[i][j]).abs() <= tol,
                    "RotationMatrix[{i}][{j}]: Rust got {}, Scipy expected {}",
                    rust_actual[i][j],
                    scipy_expected[i][j]
                );
            }
        }
    }

    #[test]
    fn scipy_identity() {
        const TOL: f32 = 1e-05_f32;
        let expected_quat = Quaternion::new(
            1.0_f32, 0.0_f32, 
            0.0_f32, 0.0_f32
        );
        let expected_aa = AxisAngle::new(
            0.0_f32, 0.0_f32, 
            0.0_f32, 0.0_f32
        );
        let expected_rv = RotationVector::new(
            0.0_f32, 0.0_f32, 
            0.0_f32
        );
        let expected_mat = RotationMatrix([
            [1.0_f32, 0.0_f32, 0.0_f32],
            [0.0_f32, 1.0_f32, 0.0_f32],
            [0.0_f32, 0.0_f32, 1.0_f32],
        ]);

        // From Quaternion -> all others
        let r = Rotation::from(expected_quat);
        assert_axis_angle_near(&r.as_axis_angle(), &expected_aa, TOL);
        assert_rotation_vector_near(&r.as_rotation_vector(), &expected_rv, TOL);
        assert_rotation_matrix_near(&r.as_rotation_matrix(), &expected_mat, TOL);

        // From AxisAngle -> Quaternion
        let r = Rotation::from(expected_aa);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);

        // From RotationVector -> Quaternion
        let r = Rotation::from(expected_rv);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);

        // From RotationMatrix -> Quaternion
        let r = Rotation::from(expected_mat);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);
    }

    #[test]
    fn scipy_near_zero_1e_6() {
        const TOL: f32 = 1e-05_f32;
        let expected_quat = Quaternion::new(
            1.0_f32, 4.999999987376214e-07_f32, 
            0.0_f32, 0.0_f32
        );
        let expected_aa = AxisAngle::new(
            1.0_f32, 0.0_f32, 
            0.0_f32, 9.999999974752427e-07_f32
        );
        let expected_rv = RotationVector::new(
            9.999999974752427e-07_f32, 0.0_f32, 
            0.0_f32
        );
        let expected_mat = RotationMatrix([
            [1.0_f32, 0.0_f32, 0.0_f32],
            [0.0_f32, 1.0_f32, -9.999999974752427e-07_f32],
            [0.0_f32, 9.999999974752427e-07_f32, 1.0_f32],
        ]);

        // From Quaternion -> all others
        let r = Rotation::from(expected_quat);
        assert_axis_angle_near(&r.as_axis_angle(), &expected_aa, TOL);
        assert_rotation_vector_near(&r.as_rotation_vector(), &expected_rv, TOL);
        assert_rotation_matrix_near(&r.as_rotation_matrix(), &expected_mat, TOL);

        // From AxisAngle -> Quaternion
        let r = Rotation::from(expected_aa);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);

        // From RotationVector -> Quaternion
        let r = Rotation::from(expected_rv);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);

        // From RotationMatrix -> Quaternion
        let r = Rotation::from(expected_mat);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);
    }

    #[test]
    fn scipy_near_zero_1e_7() {
        const TOL: f32 = 1e-05_f32;
        let expected_quat = Quaternion::new(
            1.0_f32, 5.000000058430487e-08_f32, 
            0.0_f32, 0.0_f32
        );
        let expected_aa = AxisAngle::new(
            1.0_f32, 0.0_f32, 
            0.0_f32, 1.0000000116860974e-07_f32
        );
        let expected_rv = RotationVector::new(
            1.0000000116860974e-07_f32, 0.0_f32, 
            0.0_f32
        );
        let expected_mat = RotationMatrix([
            [1.0_f32, 0.0_f32, 0.0_f32],
            [0.0_f32, 1.0_f32, -1.0000000116860974e-07_f32],
            [0.0_f32, 1.0000000116860974e-07_f32, 1.0_f32],
        ]);

        // From Quaternion -> all others
        let r = Rotation::from(expected_quat);
        assert_axis_angle_near(&r.as_axis_angle(), &expected_aa, TOL);
        assert_rotation_vector_near(&r.as_rotation_vector(), &expected_rv, TOL);
        assert_rotation_matrix_near(&r.as_rotation_matrix(), &expected_mat, TOL);

        // From AxisAngle -> Quaternion
        let r = Rotation::from(expected_aa);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);

        // From RotationVector -> Quaternion
        let r = Rotation::from(expected_rv);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);

        // From RotationMatrix -> Quaternion
        let r = Rotation::from(expected_mat);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);
    }

    #[test]
    fn scipy_near_zero_f32_eps() {
        const TOL: f32 = 1e-05_f32;
        let expected_quat = Quaternion::new(
            1.0_f32, 5.960464477539063e-08_f32, 
            0.0_f32, 0.0_f32
        );
        let expected_aa = AxisAngle::new(
            1.0_f32, 0.0_f32, 
            0.0_f32, 1.1920928955078125e-07_f32
        );
        let expected_rv = RotationVector::new(
            1.1920928955078125e-07_f32, 0.0_f32, 
            0.0_f32
        );
        let expected_mat = RotationMatrix([
            [1.0_f32, 0.0_f32, 0.0_f32],
            [0.0_f32, 1.0_f32, -1.1920928955078125e-07_f32],
            [0.0_f32, 1.1920928955078125e-07_f32, 1.0_f32],
        ]);

        // From Quaternion -> all others
        let r = Rotation::from(expected_quat);
        assert_axis_angle_near(&r.as_axis_angle(), &expected_aa, TOL);
        assert_rotation_vector_near(&r.as_rotation_vector(), &expected_rv, TOL);
        assert_rotation_matrix_near(&r.as_rotation_matrix(), &expected_mat, TOL);

        // From AxisAngle -> Quaternion
        let r = Rotation::from(expected_aa);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);

        // From RotationVector -> Quaternion
        let r = Rotation::from(expected_rv);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);

        // From RotationMatrix -> Quaternion
        let r = Rotation::from(expected_mat);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);
    }

    #[test]
    fn scipy_angle_pi_over_4() {
        const TOL: f32 = 1e-05_f32;
        let expected_quat = Quaternion::new(
            0.9238795042037964_f32, 0.3826834261417389_f32, 
            0.0_f32, 0.0_f32
        );
        let expected_aa = AxisAngle::new(
            1.0_f32, 0.0_f32, 
            0.0_f32, 0.7853981852531433_f32
        );
        let expected_rv = RotationVector::new(
            0.7853981852531433_f32, 0.0_f32, 
            0.0_f32
        );
        let expected_mat = RotationMatrix([
            [1.0_f32, 0.0_f32, 0.0_f32],
            [0.0_f32, 0.7071067690849304_f32, -0.7071067690849304_f32],
            [0.0_f32, 0.7071067690849304_f32, 0.7071067690849304_f32],
        ]);

        // From Quaternion -> all others
        let r = Rotation::from(expected_quat);
        assert_axis_angle_near(&r.as_axis_angle(), &expected_aa, TOL);
        assert_rotation_vector_near(&r.as_rotation_vector(), &expected_rv, TOL);
        assert_rotation_matrix_near(&r.as_rotation_matrix(), &expected_mat, TOL);

        // From AxisAngle -> Quaternion
        let r = Rotation::from(expected_aa);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);

        // From RotationVector -> Quaternion
        let r = Rotation::from(expected_rv);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);

        // From RotationMatrix -> Quaternion
        let r = Rotation::from(expected_mat);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);
    }

    #[test]
    fn scipy_angle_pi_over_2() {
        const TOL: f32 = 1e-05_f32;
        let expected_quat = Quaternion::new(
            0.7071067690849304_f32, 0.7071067690849304_f32, 
            0.0_f32, 0.0_f32
        );
        let expected_aa = AxisAngle::new(
            1.0_f32, 0.0_f32, 
            0.0_f32, 1.5707963705062866_f32
        );
        let expected_rv = RotationVector::new(
            1.5707963705062866_f32, 0.0_f32, 
            0.0_f32
        );
        let expected_mat = RotationMatrix([
            [1.0_f32, 0.0_f32, 0.0_f32],
            [0.0_f32, 2.220446049250313e-16_f32, -1.0_f32],
            [0.0_f32, 1.0_f32, 2.220446049250313e-16_f32],
        ]);

        // From Quaternion -> all others
        let r = Rotation::from(expected_quat);
        assert_axis_angle_near(&r.as_axis_angle(), &expected_aa, TOL);
        assert_rotation_vector_near(&r.as_rotation_vector(), &expected_rv, TOL);
        assert_rotation_matrix_near(&r.as_rotation_matrix(), &expected_mat, TOL);

        // From AxisAngle -> Quaternion
        let r = Rotation::from(expected_aa);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);

        // From RotationVector -> Quaternion
        let r = Rotation::from(expected_rv);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);

        // From RotationMatrix -> Quaternion
        let r = Rotation::from(expected_mat);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);
    }

    #[test]
    fn scipy_angle_pi() {
        const TOL: f32 = 1e-05_f32;
        let expected_quat = Quaternion::new(
            6.123234262925839e-17_f32, 1.0_f32, 
            0.0_f32, 0.0_f32
        );
        let expected_aa = AxisAngle::new(
            1.0_f32, 0.0_f32, 
            0.0_f32, 3.1415927410125732_f32
        );
        let expected_rv = RotationVector::new(
            3.1415927410125732_f32, 0.0_f32, 
            0.0_f32
        );
        let expected_mat = RotationMatrix([
            [1.0_f32, 0.0_f32, 0.0_f32],
            [0.0_f32, -1.0_f32, -1.2246468525851679e-16_f32],
            [0.0_f32, 1.2246468525851679e-16_f32, -1.0_f32],
        ]);

        // From Quaternion -> all others
        let r = Rotation::from(expected_quat);
        assert_axis_angle_near(&r.as_axis_angle(), &expected_aa, TOL);
        assert_rotation_vector_near(&r.as_rotation_vector(), &expected_rv, TOL);
        assert_rotation_matrix_near(&r.as_rotation_matrix(), &expected_mat, TOL);

        // From AxisAngle -> Quaternion
        let r = Rotation::from(expected_aa);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);

        // From RotationVector -> Quaternion
        let r = Rotation::from(expected_rv);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);

        // From RotationMatrix -> Quaternion
        let r = Rotation::from(expected_mat);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);
    }

    #[test]
    fn scipy_angle_3pi_over_2() {
        const TOL: f32 = 1e-05_f32;
        let expected_quat = Quaternion::new(
            -0.7071067690849304_f32, 0.7071067690849304_f32, 
            0.0_f32, 0.0_f32
        );
        let expected_aa = AxisAngle::new(
            -1.0_f32, -0.0_f32, 
            -0.0_f32, 1.5707963705062866_f32
        );
        let expected_rv = RotationVector::new(
            -1.5707963705062866_f32, -0.0_f32, 
            -0.0_f32
        );
        let expected_mat = RotationMatrix([
            [1.0_f32, 0.0_f32, 0.0_f32],
            [0.0_f32, -2.220446049250313e-16_f32, 1.0_f32],
            [0.0_f32, -1.0_f32, -2.220446049250313e-16_f32],
        ]);

        // From Quaternion -> all others
        let r = Rotation::from(expected_quat);
        assert_axis_angle_near(&r.as_axis_angle(), &expected_aa, TOL);
        assert_rotation_vector_near(&r.as_rotation_vector(), &expected_rv, TOL);
        assert_rotation_matrix_near(&r.as_rotation_matrix(), &expected_mat, TOL);

        // From AxisAngle -> Quaternion
        let r = Rotation::from(expected_aa);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);

        // From RotationVector -> Quaternion
        let r = Rotation::from(expected_rv);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);

        // From RotationMatrix -> Quaternion
        let r = Rotation::from(expected_mat);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);
    }

    #[test]
    fn scipy_angle_2pi_minus_eps() {
        const TOL: f32 = 1e-05_f32;
        let expected_quat = Quaternion::new(
            -1.0_f32, 4.999999987376214e-07_f32, 
            0.0_f32, 0.0_f32
        );
        let expected_aa = AxisAngle::new(
            -1.0_f32, -0.0_f32, 
            -0.0_f32, 9.999999974752427e-07_f32
        );
        let expected_rv = RotationVector::new(
            -9.999999974752427e-07_f32, -0.0_f32, 
            -0.0_f32
        );
        let expected_mat = RotationMatrix([
            [1.0_f32, 0.0_f32, 0.0_f32],
            [0.0_f32, 1.0_f32, 9.999999974752427e-07_f32],
            [0.0_f32, -9.999999974752427e-07_f32, 1.0_f32],
        ]);

        // From Quaternion -> all others
        let r = Rotation::from(expected_quat);
        assert_axis_angle_near(&r.as_axis_angle(), &expected_aa, TOL);
        assert_rotation_vector_near(&r.as_rotation_vector(), &expected_rv, TOL);
        assert_rotation_matrix_near(&r.as_rotation_matrix(), &expected_mat, TOL);

        // From AxisAngle -> Quaternion
        let r = Rotation::from(expected_aa);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);

        // From RotationVector -> Quaternion
        let r = Rotation::from(expected_rv);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);

        // From RotationMatrix -> Quaternion
        let r = Rotation::from(expected_mat);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);
    }

    #[test]
    fn scipy_degrees_45() {
        const TOL: f32 = 1e-05_f32;
        let expected_quat = Quaternion::new(
            0.9238795042037964_f32, 0.3826834261417389_f32, 
            0.0_f32, 0.0_f32
        );
        let expected_aa = AxisAngle::new(
            1.0_f32, 0.0_f32, 
            0.0_f32, 0.7853981852531433_f32
        );
        let expected_rv = RotationVector::new(
            0.7853981852531433_f32, 0.0_f32, 
            0.0_f32
        );
        let expected_mat = RotationMatrix([
            [1.0_f32, 0.0_f32, 0.0_f32],
            [0.0_f32, 0.7071067690849304_f32, -0.7071067690849304_f32],
            [0.0_f32, 0.7071067690849304_f32, 0.7071067690849304_f32],
        ]);

        // From Quaternion -> all others
        let r = Rotation::from(expected_quat);
        assert_axis_angle_near(&r.as_axis_angle(), &expected_aa, TOL);
        assert_rotation_vector_near(&r.as_rotation_vector(), &expected_rv, TOL);
        assert_rotation_matrix_near(&r.as_rotation_matrix(), &expected_mat, TOL);

        // From AxisAngle -> Quaternion
        let r = Rotation::from(expected_aa);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);

        // From RotationVector -> Quaternion
        let r = Rotation::from(expected_rv);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);

        // From RotationMatrix -> Quaternion
        let r = Rotation::from(expected_mat);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);
    }

    #[test]
    fn scipy_degrees_90() {
        const TOL: f32 = 1e-05_f32;
        let expected_quat = Quaternion::new(
            0.7071067690849304_f32, 0.7071067690849304_f32, 
            0.0_f32, 0.0_f32
        );
        let expected_aa = AxisAngle::new(
            1.0_f32, 0.0_f32, 
            0.0_f32, 1.5707963705062866_f32
        );
        let expected_rv = RotationVector::new(
            1.5707963705062866_f32, 0.0_f32, 
            0.0_f32
        );
        let expected_mat = RotationMatrix([
            [1.0_f32, 0.0_f32, 0.0_f32],
            [0.0_f32, 2.220446049250313e-16_f32, -1.0_f32],
            [0.0_f32, 1.0_f32, 2.220446049250313e-16_f32],
        ]);

        // From Quaternion -> all others
        let r = Rotation::from(expected_quat);
        assert_axis_angle_near(&r.as_axis_angle(), &expected_aa, TOL);
        assert_rotation_vector_near(&r.as_rotation_vector(), &expected_rv, TOL);
        assert_rotation_matrix_near(&r.as_rotation_matrix(), &expected_mat, TOL);

        // From AxisAngle -> Quaternion
        let r = Rotation::from(expected_aa);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);

        // From RotationVector -> Quaternion
        let r = Rotation::from(expected_rv);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);

        // From RotationMatrix -> Quaternion
        let r = Rotation::from(expected_mat);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);
    }

    #[test]
    fn scipy_degrees_180() {
        const TOL: f32 = 1e-05_f32;
        let expected_quat = Quaternion::new(
            6.123234262925839e-17_f32, 1.0_f32, 
            0.0_f32, 0.0_f32
        );
        let expected_aa = AxisAngle::new(
            1.0_f32, 0.0_f32, 
            0.0_f32, 3.1415927410125732_f32
        );
        let expected_rv = RotationVector::new(
            3.1415927410125732_f32, 0.0_f32, 
            0.0_f32
        );
        let expected_mat = RotationMatrix([
            [1.0_f32, 0.0_f32, 0.0_f32],
            [0.0_f32, -1.0_f32, -1.2246468525851679e-16_f32],
            [0.0_f32, 1.2246468525851679e-16_f32, -1.0_f32],
        ]);

        // From Quaternion -> all others
        let r = Rotation::from(expected_quat);
        assert_axis_angle_near(&r.as_axis_angle(), &expected_aa, TOL);
        assert_rotation_vector_near(&r.as_rotation_vector(), &expected_rv, TOL);
        assert_rotation_matrix_near(&r.as_rotation_matrix(), &expected_mat, TOL);

        // From AxisAngle -> Quaternion
        let r = Rotation::from(expected_aa);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);

        // From RotationVector -> Quaternion
        let r = Rotation::from(expected_rv);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);

        // From RotationMatrix -> Quaternion
        let r = Rotation::from(expected_mat);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);
    }

    #[test]
    fn scipy_degrees_270() {
        const TOL: f32 = 1e-05_f32;
        let expected_quat = Quaternion::new(
            -0.7071067690849304_f32, 0.7071067690849304_f32, 
            0.0_f32, 0.0_f32
        );
        let expected_aa = AxisAngle::new(
            -1.0_f32, -0.0_f32, 
            -0.0_f32, 1.5707963705062866_f32
        );
        let expected_rv = RotationVector::new(
            -1.5707963705062866_f32, -0.0_f32, 
            -0.0_f32
        );
        let expected_mat = RotationMatrix([
            [1.0_f32, 0.0_f32, 0.0_f32],
            [0.0_f32, -2.220446049250313e-16_f32, 1.0_f32],
            [0.0_f32, -1.0_f32, -2.220446049250313e-16_f32],
        ]);

        // From Quaternion -> all others
        let r = Rotation::from(expected_quat);
        assert_axis_angle_near(&r.as_axis_angle(), &expected_aa, TOL);
        assert_rotation_vector_near(&r.as_rotation_vector(), &expected_rv, TOL);
        assert_rotation_matrix_near(&r.as_rotation_matrix(), &expected_mat, TOL);

        // From AxisAngle -> Quaternion
        let r = Rotation::from(expected_aa);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);

        // From RotationVector -> Quaternion
        let r = Rotation::from(expected_rv);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);

        // From RotationMatrix -> Quaternion
        let r = Rotation::from(expected_mat);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);
    }

    #[test]
    fn scipy_degrees_360() {
        const TOL: f32 = 1e-05_f32;
        let expected_quat = Quaternion::new(
            -1.0_f32, 1.2246468525851679e-16_f32, 
            0.0_f32, 0.0_f32
        );
        let expected_aa = AxisAngle::new(
            0.0_f32, 0.0_f32, 
            0.0_f32, 0.0_f32
        );
        let expected_rv = RotationVector::new(
            0.0_f32, 0.0_f32, 
            0.0_f32
        );
        let expected_mat = RotationMatrix([
            [1.0_f32, 0.0_f32, 0.0_f32],
            [0.0_f32, 1.0_f32, 2.4492937051703357e-16_f32],
            [0.0_f32, -2.4492937051703357e-16_f32, 1.0_f32],
        ]);

        // From Quaternion -> all others
        let r = Rotation::from(expected_quat);
        assert_axis_angle_near(&r.as_axis_angle(), &expected_aa, TOL);
        assert_rotation_vector_near(&r.as_rotation_vector(), &expected_rv, TOL);
        assert_rotation_matrix_near(&r.as_rotation_matrix(), &expected_mat, TOL);

        // From AxisAngle -> Quaternion
        let r = Rotation::from(expected_aa);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);

        // From RotationVector -> Quaternion
        let r = Rotation::from(expected_rv);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);

        // From RotationMatrix -> Quaternion
        let r = Rotation::from(expected_mat);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);
    }

    #[test]
    fn scipy_axis_y() {
        const TOL: f32 = 1e-05_f32;
        let expected_quat = Quaternion::new(
            0.8660253882408142_f32, 0.0_f32, 
            0.5_f32, 0.0_f32
        );
        let expected_aa = AxisAngle::new(
            0.0_f32, 1.0_f32, 
            0.0_f32, 1.0471975803375244_f32
        );
        let expected_rv = RotationVector::new(
            0.0_f32, 1.0471975803375244_f32, 
            0.0_f32
        );
        let expected_mat = RotationMatrix([
            [0.5_f32, 0.0_f32, 0.8660253882408142_f32],
            [0.0_f32, 1.0_f32, 0.0_f32],
            [-0.8660253882408142_f32, 0.0_f32, 0.5_f32],
        ]);

        // From Quaternion -> all others
        let r = Rotation::from(expected_quat);
        assert_axis_angle_near(&r.as_axis_angle(), &expected_aa, TOL);
        assert_rotation_vector_near(&r.as_rotation_vector(), &expected_rv, TOL);
        assert_rotation_matrix_near(&r.as_rotation_matrix(), &expected_mat, TOL);

        // From AxisAngle -> Quaternion
        let r = Rotation::from(expected_aa);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);

        // From RotationVector -> Quaternion
        let r = Rotation::from(expected_rv);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);

        // From RotationMatrix -> Quaternion
        let r = Rotation::from(expected_mat);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);
    }

    #[test]
    fn scipy_axis_z() {
        const TOL: f32 = 1e-05_f32;
        let expected_quat = Quaternion::new(
            0.8660253882408142_f32, 0.0_f32, 
            0.0_f32, 0.5_f32
        );
        let expected_aa = AxisAngle::new(
            0.0_f32, 0.0_f32, 
            1.0_f32, 1.0471975803375244_f32
        );
        let expected_rv = RotationVector::new(
            0.0_f32, 0.0_f32, 
            1.0471975803375244_f32
        );
        let expected_mat = RotationMatrix([
            [0.5_f32, -0.8660253882408142_f32, 0.0_f32],
            [0.8660253882408142_f32, 0.5_f32, 0.0_f32],
            [0.0_f32, 0.0_f32, 1.0_f32],
        ]);

        // From Quaternion -> all others
        let r = Rotation::from(expected_quat);
        assert_axis_angle_near(&r.as_axis_angle(), &expected_aa, TOL);
        assert_rotation_vector_near(&r.as_rotation_vector(), &expected_rv, TOL);
        assert_rotation_matrix_near(&r.as_rotation_matrix(), &expected_mat, TOL);

        // From AxisAngle -> Quaternion
        let r = Rotation::from(expected_aa);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);

        // From RotationVector -> Quaternion
        let r = Rotation::from(expected_rv);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);

        // From RotationMatrix -> Quaternion
        let r = Rotation::from(expected_mat);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);
    }

    #[test]
    fn scipy_axis_xy() {
        const TOL: f32 = 1e-05_f32;
        let expected_quat = Quaternion::new(
            0.8660253882408142_f32, 0.3535533845424652_f32, 
            0.3535533845424652_f32, 0.0_f32
        );
        let expected_aa = AxisAngle::new(
            0.7071067690849304_f32, 0.7071067690849304_f32, 
            0.0_f32, 1.0471975803375244_f32
        );
        let expected_rv = RotationVector::new(
            0.7404804825782776_f32, 0.7404804825782776_f32, 
            0.0_f32
        );
        let expected_mat = RotationMatrix([
            [0.75_f32, 0.25_f32, 0.6123724579811096_f32],
            [0.25_f32, 0.75_f32, -0.6123724579811096_f32],
            [-0.6123724579811096_f32, 0.6123724579811096_f32, 0.5_f32],
        ]);

        // From Quaternion -> all others
        let r = Rotation::from(expected_quat);
        assert_axis_angle_near(&r.as_axis_angle(), &expected_aa, TOL);
        assert_rotation_vector_near(&r.as_rotation_vector(), &expected_rv, TOL);
        assert_rotation_matrix_near(&r.as_rotation_matrix(), &expected_mat, TOL);

        // From AxisAngle -> Quaternion
        let r = Rotation::from(expected_aa);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);

        // From RotationVector -> Quaternion
        let r = Rotation::from(expected_rv);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);

        // From RotationMatrix -> Quaternion
        let r = Rotation::from(expected_mat);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);
    }

    #[test]
    fn scipy_axis_xyz() {
        const TOL: f32 = 1e-05_f32;
        let expected_quat = Quaternion::new(
            0.8660253882408142_f32, 0.28867512941360474_f32, 
            0.28867512941360474_f32, 0.28867512941360474_f32
        );
        let expected_aa = AxisAngle::new(
            0.5773502588272095_f32, 0.5773502588272095_f32, 
            0.5773502588272095_f32, 1.0471975803375244_f32
        );
        let expected_rv = RotationVector::new(
            0.6045998334884644_f32, 0.6045998334884644_f32, 
            0.6045998334884644_f32
        );
        let expected_mat = RotationMatrix([
            [0.6666666865348816_f32, -0.3333333432674408_f32, 0.6666666865348816_f32],
            [0.6666666865348816_f32, 0.6666666865348816_f32, -0.3333333432674408_f32],
            [-0.3333333432674408_f32, 0.6666666865348816_f32, 0.6666666865348816_f32],
        ]);

        // From Quaternion -> all others
        let r = Rotation::from(expected_quat);
        assert_axis_angle_near(&r.as_axis_angle(), &expected_aa, TOL);
        assert_rotation_vector_near(&r.as_rotation_vector(), &expected_rv, TOL);
        assert_rotation_matrix_near(&r.as_rotation_matrix(), &expected_mat, TOL);

        // From AxisAngle -> Quaternion
        let r = Rotation::from(expected_aa);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);

        // From RotationVector -> Quaternion
        let r = Rotation::from(expected_rv);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);

        // From RotationMatrix -> Quaternion
        let r = Rotation::from(expected_mat);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);
    }

    #[test]
    fn scipy_axis_arbitrary() {
        const TOL: f32 = 1e-05_f32;
        let expected_quat = Quaternion::new(
            0.8660253882408142_f32, 0.4319342076778412_f32, 
            -0.2159671038389206_f32, 0.12958025932312012_f32
        );
        let expected_aa = AxisAngle::new(
            0.8638684153556824_f32, -0.4319342076778412_f32, 
            0.25916051864624023_f32, 1.0471975803375244_f32
        );
        let expected_rv = RotationVector::new(
            0.9046409130096436_f32, -0.4523204565048218_f32, 
            0.271392285823822_f32
        );
        let expected_mat = RotationMatrix([
            [0.8731343150138855_f32, -0.41100677847862244_f32, -0.262125700712204_f32],
            [0.03787243738770485_f32, 0.5932835936546326_f32, -0.8041021227836609_f32],
            [0.4860062897205353_f32, 0.6921618580818176_f32, 0.5335820913314819_f32],
        ]);

        // From Quaternion -> all others
        let r = Rotation::from(expected_quat);
        assert_axis_angle_near(&r.as_axis_angle(), &expected_aa, TOL);
        assert_rotation_vector_near(&r.as_rotation_vector(), &expected_rv, TOL);
        assert_rotation_matrix_near(&r.as_rotation_matrix(), &expected_mat, TOL);

        // From AxisAngle -> Quaternion
        let r = Rotation::from(expected_aa);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);

        // From RotationVector -> Quaternion
        let r = Rotation::from(expected_rv);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);

        // From RotationMatrix -> Quaternion
        let r = Rotation::from(expected_mat);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);
    }

    #[test]
    fn scipy_quat_w_near_1() {
        const TOL: f32 = 1e-05_f32;
        let expected_quat = Quaternion::new(
            1.0_f32, 1.1920928955078125e-07_f32, 
            0.0_f32, 0.0_f32
        );
        let expected_aa = AxisAngle::new(
            1.0_f32, 0.0_f32, 
            0.0_f32, 2.384185791015625e-07_f32
        );
        let expected_rv = RotationVector::new(
            2.384185791015625e-07_f32, 0.0_f32, 
            0.0_f32
        );
        let expected_mat = RotationMatrix([
            [1.0_f32, 0.0_f32, 0.0_f32],
            [0.0_f32, 1.0_f32, -2.384185791015625e-07_f32],
            [0.0_f32, 2.384185791015625e-07_f32, 1.0_f32],
        ]);

        // From Quaternion -> all others
        let r = Rotation::from(expected_quat);
        assert_axis_angle_near(&r.as_axis_angle(), &expected_aa, TOL);
        assert_rotation_vector_near(&r.as_rotation_vector(), &expected_rv, TOL);
        assert_rotation_matrix_near(&r.as_rotation_matrix(), &expected_mat, TOL);

        // From AxisAngle -> Quaternion
        let r = Rotation::from(expected_aa);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);

        // From RotationVector -> Quaternion
        let r = Rotation::from(expected_rv);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);

        // From RotationMatrix -> Quaternion
        let r = Rotation::from(expected_mat);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);
    }

    #[test]
    fn scipy_quat_w_zero_180deg_x() {
        const TOL: f32 = 1e-05_f32;
        let expected_quat = Quaternion::new(
            0.0_f32, 1.0_f32, 
            0.0_f32, 0.0_f32
        );
        let expected_aa = AxisAngle::new(
            1.0_f32, 0.0_f32, 
            0.0_f32, 3.1415927410125732_f32
        );
        let expected_rv = RotationVector::new(
            3.1415927410125732_f32, 0.0_f32, 
            0.0_f32
        );
        let expected_mat = RotationMatrix([
            [1.0_f32, 0.0_f32, 0.0_f32],
            [0.0_f32, -1.0_f32, 0.0_f32],
            [0.0_f32, 0.0_f32, -1.0_f32],
        ]);

        // From Quaternion -> all others
        let r = Rotation::from(expected_quat);
        assert_axis_angle_near(&r.as_axis_angle(), &expected_aa, TOL);
        assert_rotation_vector_near(&r.as_rotation_vector(), &expected_rv, TOL);
        assert_rotation_matrix_near(&r.as_rotation_matrix(), &expected_mat, TOL);

        // From AxisAngle -> Quaternion
        let r = Rotation::from(expected_aa);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);

        // From RotationVector -> Quaternion
        let r = Rotation::from(expected_rv);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);

        // From RotationMatrix -> Quaternion
        let r = Rotation::from(expected_mat);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);
    }

    #[test]
    fn scipy_quat_w_near_minus_1() {
        const TOL: f32 = 1e-05_f32;
        let expected_quat = Quaternion::new(
            0.0_f32, -1.0_f32, 
            0.0_f32, 0.0_f32
        );
        let expected_aa = AxisAngle::new(
            1.0_f32, -0.0_f32, 
            -0.0_f32, 3.1415927410125732_f32
        );
        let expected_rv = RotationVector::new(
            3.1415927410125732_f32, -0.0_f32, 
            -0.0_f32
        );
        let expected_mat = RotationMatrix([
            [1.0_f32, -0.0_f32, 0.0_f32],
            [0.0_f32, -1.0_f32, 0.0_f32],
            [-0.0_f32, 0.0_f32, -1.0_f32],
        ]);

        // From Quaternion -> all others
        let r = Rotation::from(expected_quat);
        assert_axis_angle_near(&r.as_axis_angle(), &expected_aa, TOL);
        assert_rotation_vector_near(&r.as_rotation_vector(), &expected_rv, TOL);
        assert_rotation_matrix_near(&r.as_rotation_matrix(), &expected_mat, TOL);

        // From AxisAngle -> Quaternion
        let r = Rotation::from(expected_aa);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);

        // From RotationVector -> Quaternion
        let r = Rotation::from(expected_rv);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);

        // From RotationMatrix -> Quaternion
        let r = Rotation::from(expected_mat);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);
    }

    #[test]
    fn scipy_matrix_90deg_z() {
        const TOL: f32 = 1e-05_f32;
        let expected_quat = Quaternion::new(
            0.7071067690849304_f32, 0.0_f32, 
            0.0_f32, 0.7071067690849304_f32
        );
        let expected_aa = AxisAngle::new(
            0.0_f32, 0.0_f32, 
            1.0_f32, 1.5707963705062866_f32
        );
        let expected_rv = RotationVector::new(
            0.0_f32, 0.0_f32, 
            1.5707963705062866_f32
        );
        let expected_mat = RotationMatrix([
            [0.0_f32, -1.0_f32, 0.0_f32],
            [1.0_f32, 0.0_f32, 0.0_f32],
            [0.0_f32, 0.0_f32, 1.0_f32],
        ]);

        // From Quaternion -> all others
        let r = Rotation::from(expected_quat);
        assert_axis_angle_near(&r.as_axis_angle(), &expected_aa, TOL);
        assert_rotation_vector_near(&r.as_rotation_vector(), &expected_rv, TOL);
        assert_rotation_matrix_near(&r.as_rotation_matrix(), &expected_mat, TOL);

        // From AxisAngle -> Quaternion
        let r = Rotation::from(expected_aa);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);

        // From RotationVector -> Quaternion
        let r = Rotation::from(expected_rv);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);

        // From RotationMatrix -> Quaternion
        let r = Rotation::from(expected_mat);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);
    }

    #[test]
    fn scipy_euler_xyz_30_45_60() {
        const TOL: f32 = 1e-05_f32;
        let expected_quat = Quaternion::new(
            0.8223631978034973_f32, 0.0222600270062685_f32, 
            0.43967974185943604_f32, 0.36042341589927673_f32
        );
        let expected_aa = AxisAngle::new(
            0.039123862981796265_f32, 0.7727739810943604_f32, 
            0.6334743499755859_f32, 1.2104884386062622_f32
        );
        let expected_rv = RotationVector::new(
            0.047358982264995575_f32, 0.9354339241981506_f32, 
            0.766813337802887_f32
        );
        let expected_mat = RotationMatrix([
            [0.3535533845424652_f32, -0.5732232928276062_f32, 0.7391989231109619_f32],
            [0.6123724579811096_f32, 0.7391989231109619_f32, 0.280330091714859_f32],
            [-0.7071067690849304_f32, 0.3535533845424652_f32, 0.6123724579811096_f32],
        ]);

        // From Quaternion -> all others
        let r = Rotation::from(expected_quat);
        assert_axis_angle_near(&r.as_axis_angle(), &expected_aa, TOL);
        assert_rotation_vector_near(&r.as_rotation_vector(), &expected_rv, TOL);
        assert_rotation_matrix_near(&r.as_rotation_matrix(), &expected_mat, TOL);

        // From AxisAngle -> Quaternion
        let r = Rotation::from(expected_aa);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);

        // From RotationVector -> Quaternion
        let r = Rotation::from(expected_rv);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);

        // From RotationMatrix -> Quaternion
        let r = Rotation::from(expected_mat);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);
    }

    #[test]
    fn scipy_euler_xyz_90_0_0() {
        const TOL: f32 = 1e-05_f32;
        let expected_quat = Quaternion::new(
            0.7071067690849304_f32, 0.7071067690849304_f32, 
            0.0_f32, 0.0_f32
        );
        let expected_aa = AxisAngle::new(
            1.0_f32, 0.0_f32, 
            0.0_f32, 1.5707963705062866_f32
        );
        let expected_rv = RotationVector::new(
            1.5707963705062866_f32, 0.0_f32, 
            0.0_f32
        );
        let expected_mat = RotationMatrix([
            [1.0_f32, 0.0_f32, 0.0_f32],
            [0.0_f32, 2.220446049250313e-16_f32, -1.0_f32],
            [0.0_f32, 1.0_f32, 2.220446049250313e-16_f32],
        ]);

        // From Quaternion -> all others
        let r = Rotation::from(expected_quat);
        assert_axis_angle_near(&r.as_axis_angle(), &expected_aa, TOL);
        assert_rotation_vector_near(&r.as_rotation_vector(), &expected_rv, TOL);
        assert_rotation_matrix_near(&r.as_rotation_matrix(), &expected_mat, TOL);

        // From AxisAngle -> Quaternion
        let r = Rotation::from(expected_aa);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);

        // From RotationVector -> Quaternion
        let r = Rotation::from(expected_rv);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);

        // From RotationMatrix -> Quaternion
        let r = Rotation::from(expected_mat);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);
    }

    #[test]
    fn scipy_euler_xyz_0_90_0() {
        const TOL: f32 = 1e-05_f32;
        let expected_quat = Quaternion::new(
            0.7071067690849304_f32, 0.0_f32, 
            0.7071067690849304_f32, 0.0_f32
        );
        let expected_aa = AxisAngle::new(
            0.0_f32, 1.0_f32, 
            0.0_f32, 1.5707963705062866_f32
        );
        let expected_rv = RotationVector::new(
            0.0_f32, 1.5707963705062866_f32, 
            0.0_f32
        );
        let expected_mat = RotationMatrix([
            [2.220446049250313e-16_f32, 0.0_f32, 1.0_f32],
            [0.0_f32, 1.0_f32, 0.0_f32],
            [-1.0_f32, 0.0_f32, 2.220446049250313e-16_f32],
        ]);

        // From Quaternion -> all others
        let r = Rotation::from(expected_quat);
        assert_axis_angle_near(&r.as_axis_angle(), &expected_aa, TOL);
        assert_rotation_vector_near(&r.as_rotation_vector(), &expected_rv, TOL);
        assert_rotation_matrix_near(&r.as_rotation_matrix(), &expected_mat, TOL);

        // From AxisAngle -> Quaternion
        let r = Rotation::from(expected_aa);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);

        // From RotationVector -> Quaternion
        let r = Rotation::from(expected_rv);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);

        // From RotationMatrix -> Quaternion
        let r = Rotation::from(expected_mat);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);
    }

    #[test]
    fn scipy_euler_xyz_0_0_90() {
        const TOL: f32 = 1e-05_f32;
        let expected_quat = Quaternion::new(
            0.7071067690849304_f32, 0.0_f32, 
            0.0_f32, 0.7071067690849304_f32
        );
        let expected_aa = AxisAngle::new(
            0.0_f32, 0.0_f32, 
            1.0_f32, 1.5707963705062866_f32
        );
        let expected_rv = RotationVector::new(
            0.0_f32, 0.0_f32, 
            1.5707963705062866_f32
        );
        let expected_mat = RotationMatrix([
            [2.220446049250313e-16_f32, -1.0_f32, 0.0_f32],
            [1.0_f32, 2.220446049250313e-16_f32, 0.0_f32],
            [0.0_f32, 0.0_f32, 1.0_f32],
        ]);

        // From Quaternion -> all others
        let r = Rotation::from(expected_quat);
        assert_axis_angle_near(&r.as_axis_angle(), &expected_aa, TOL);
        assert_rotation_vector_near(&r.as_rotation_vector(), &expected_rv, TOL);
        assert_rotation_matrix_near(&r.as_rotation_matrix(), &expected_mat, TOL);

        // From AxisAngle -> Quaternion
        let r = Rotation::from(expected_aa);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);

        // From RotationVector -> Quaternion
        let r = Rotation::from(expected_rv);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);

        // From RotationMatrix -> Quaternion
        let r = Rotation::from(expected_mat);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);
    }

    #[test]
    fn scipy_euler_xyz_gimbal_like() {
        const TOL: f32 = 1e-05_f32;
        let expected_quat = Quaternion::new(
            0.5_f32, 0.5_f32, 
            0.5_f32, -0.5_f32
        );
        let expected_aa = AxisAngle::new(
            0.5773502588272095_f32, 0.5773502588272095_f32, 
            -0.5773502588272095_f32, 2.094395160675049_f32
        );
        let expected_rv = RotationVector::new(
            1.2091996669769287_f32, 1.2091996669769287_f32, 
            -1.2091996669769287_f32
        );
        let expected_mat = RotationMatrix([
            [2.220446049250313e-16_f32, 1.0_f32, 2.220446049250313e-16_f32],
            [0.0_f32, 2.220446049250313e-16_f32, -1.0_f32],
            [-1.0_f32, 2.220446049250313e-16_f32, 0.0_f32],
        ]);

        // From Quaternion -> all others
        let r = Rotation::from(expected_quat);
        assert_axis_angle_near(&r.as_axis_angle(), &expected_aa, TOL);
        assert_rotation_vector_near(&r.as_rotation_vector(), &expected_rv, TOL);
        assert_rotation_matrix_near(&r.as_rotation_matrix(), &expected_mat, TOL);

        // From AxisAngle -> Quaternion
        let r = Rotation::from(expected_aa);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);

        // From RotationVector -> Quaternion
        let r = Rotation::from(expected_rv);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);

        // From RotationMatrix -> Quaternion
        let r = Rotation::from(expected_mat);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);
    }

    #[test]
    fn scipy_f32_min_rotation() {
        const TOL: f32 = 1e-05_f32;
        let expected_quat = Quaternion::new(
            1.0_f32, 5.960464477539063e-08_f32, 
            0.0_f32, 0.0_f32
        );
        let expected_aa = AxisAngle::new(
            1.0_f32, 0.0_f32, 
            0.0_f32, 1.1920928955078125e-07_f32
        );
        let expected_rv = RotationVector::new(
            1.1920928955078125e-07_f32, 0.0_f32, 
            0.0_f32
        );
        let expected_mat = RotationMatrix([
            [1.0_f32, 0.0_f32, 0.0_f32],
            [0.0_f32, 1.0_f32, -1.1920928955078125e-07_f32],
            [0.0_f32, 1.1920928955078125e-07_f32, 1.0_f32],
        ]);

        // From Quaternion -> all others
        let r = Rotation::from(expected_quat);
        assert_axis_angle_near(&r.as_axis_angle(), &expected_aa, TOL);
        assert_rotation_vector_near(&r.as_rotation_vector(), &expected_rv, TOL);
        assert_rotation_matrix_near(&r.as_rotation_matrix(), &expected_mat, TOL);

        // From AxisAngle -> Quaternion
        let r = Rotation::from(expected_aa);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);

        // From RotationVector -> Quaternion
        let r = Rotation::from(expected_rv);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);

        // From RotationMatrix -> Quaternion
        let r = Rotation::from(expected_mat);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);
    }

    #[test]
    fn scipy_f32_angle_near_2pi() {
        const TOL: f32 = 1e-05_f32;
        let expected_quat = Quaternion::new(
            -1.0_f32, -8.742277657347586e-08_f32, 
            -0.0_f32, -0.0_f32
        );
        let expected_aa = AxisAngle::new(
            1.0_f32, 0.0_f32, 
            0.0_f32, 1.7484555314695172e-07_f32
        );
        let expected_rv = RotationVector::new(
            1.7484555314695172e-07_f32, 0.0_f32, 
            0.0_f32
        );
        let expected_mat = RotationMatrix([
            [1.0_f32, 0.0_f32, 0.0_f32],
            [0.0_f32, 1.0_f32, -1.7484555314695172e-07_f32],
            [0.0_f32, 1.7484555314695172e-07_f32, 1.0_f32],
        ]);

        // From Quaternion -> all others
        let r = Rotation::from(expected_quat);
        assert_axis_angle_near(&r.as_axis_angle(), &expected_aa, TOL);
        assert_rotation_vector_near(&r.as_rotation_vector(), &expected_rv, TOL);
        assert_rotation_matrix_near(&r.as_rotation_matrix(), &expected_mat, TOL);

        // From AxisAngle -> Quaternion
        let r = Rotation::from(expected_aa);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);

        // From RotationVector -> Quaternion
        let r = Rotation::from(expected_rv);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);

        // From RotationMatrix -> Quaternion
        let r = Rotation::from(expected_mat);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);
    }

    #[test]
    fn scipy_quat_components_near_limits() {
        const TOL: f32 = 5.5e-05_f32;
        let expected_quat = Quaternion::new(
            0.00010000001202570274_f32, 1.0_f32, 
            0.00010000001202570274_f32, 0.00010000001202570274_f32
        );
        let expected_aa = AxisAngle::new(
            1.0_f32, 0.00010000001202570274_f32, 
            0.00010000001202570274_f32, 3.141392707824707_f32
        );
        let expected_rv = RotationVector::new(
            3.141392707824707_f32, 0.0003141392953693867_f32, 
            0.0003141392953693867_f32
        );
        let expected_mat = RotationMatrix([
            [0.9999999403953552_f32, 0.00019998001516796649_f32, 0.00020002001838292927_f32],
            [0.00020002001838292927_f32, -0.9999999403953552_f32, -0.00019998001516796649_f32],
            [0.00019998001516796649_f32, 0.00020002001838292927_f32, -0.9999999403953552_f32],
        ]);

        // From Quaternion -> all others
        let r = Rotation::from(expected_quat);
        assert_axis_angle_near(&r.as_axis_angle(), &expected_aa, TOL);
        assert_rotation_vector_near(&r.as_rotation_vector(), &expected_rv, TOL);
        assert_rotation_matrix_near(&r.as_rotation_matrix(), &expected_mat, TOL);

        // From AxisAngle -> Quaternion
        let r = Rotation::from(expected_aa);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);

        // From RotationVector -> Quaternion
        let r = Rotation::from(expected_rv);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);

        // From RotationMatrix -> Quaternion
        let r = Rotation::from(expected_mat);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);
    }

    #[test]
    fn scipy_rotvec_angle_gt_2pi() {
        const TOL: f32 = 1e-05_f32;
        let expected_quat = Quaternion::new(
            -0.9238795042037964_f32, -0.3826834261417389_f32, 
            -0.0_f32, -0.0_f32
        );
        let expected_aa = AxisAngle::new(
            1.0_f32, 0.0_f32, 
            0.0_f32, 0.7853981852531433_f32
        );
        let expected_rv = RotationVector::new(
            0.7853981852531433_f32, 0.0_f32, 
            0.0_f32
        );
        let expected_mat = RotationMatrix([
            [1.0_f32, 0.0_f32, 0.0_f32],
            [0.0_f32, 0.7071067690849304_f32, -0.7071067690849304_f32],
            [0.0_f32, 0.7071067690849304_f32, 0.7071067690849304_f32],
        ]);

        // From Quaternion -> all others
        let r = Rotation::from(expected_quat);
        assert_axis_angle_near(&r.as_axis_angle(), &expected_aa, TOL);
        assert_rotation_vector_near(&r.as_rotation_vector(), &expected_rv, TOL);
        assert_rotation_matrix_near(&r.as_rotation_matrix(), &expected_mat, TOL);

        // From AxisAngle -> Quaternion
        let r = Rotation::from(expected_aa);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);

        // From RotationVector -> Quaternion
        let r = Rotation::from(expected_rv);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);

        // From RotationMatrix -> Quaternion
        let r = Rotation::from(expected_mat);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);
    }

    #[test]
    fn scipy_rotvec_zero() {
        const TOL: f32 = 1e-05_f32;
        let expected_quat = Quaternion::new(
            1.0_f32, 0.0_f32, 
            0.0_f32, 0.0_f32
        );
        let expected_aa = AxisAngle::new(
            0.0_f32, 0.0_f32, 
            0.0_f32, 0.0_f32
        );
        let expected_rv = RotationVector::new(
            0.0_f32, 0.0_f32, 
            0.0_f32
        );
        let expected_mat = RotationMatrix([
            [1.0_f32, 0.0_f32, 0.0_f32],
            [0.0_f32, 1.0_f32, 0.0_f32],
            [0.0_f32, 0.0_f32, 1.0_f32],
        ]);

        // From Quaternion -> all others
        let r = Rotation::from(expected_quat);
        assert_axis_angle_near(&r.as_axis_angle(), &expected_aa, TOL);
        assert_rotation_vector_near(&r.as_rotation_vector(), &expected_rv, TOL);
        assert_rotation_matrix_near(&r.as_rotation_matrix(), &expected_mat, TOL);

        // From AxisAngle -> Quaternion
        let r = Rotation::from(expected_aa);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);

        // From RotationVector -> Quaternion
        let r = Rotation::from(expected_rv);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);

        // From RotationMatrix -> Quaternion
        let r = Rotation::from(expected_mat);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);
    }

    #[test]
    fn scipy_random_0() {
        const TOL: f32 = 1e-05_f32;
        let expected_quat = Quaternion::new(
            0.5808325409889221_f32, 0.18817375600337982_f32, 
            -0.6422275900840759_f32, 0.46343061327934265_f32
        );
        let expected_aa = AxisAngle::new(
            0.23116514086723328_f32, -0.78895503282547_f32, 
            0.5693089365959167_f32, 1.9020905494689941_f32
        );
        let expected_rv = RotationVector::new(
            0.4396970272064209_f32, -1.5006638765335083_f32, 
            1.0828771591186523_f32
        );
        let expected_mat = RotationMatrix([
            [-0.25444838404655457_f32, -0.7800518870353699_f32, -0.5716423988342285_f32],
            [0.29665037989616394_f32, 0.4996454417705536_f32, -0.8138507008552551_f32],
            [0.9204643368721008_f32, -0.37666094303131104_f32, 0.10426872223615646_f32],
        ]);

        // From Quaternion -> all others
        let r = Rotation::from(expected_quat);
        assert_axis_angle_near(&r.as_axis_angle(), &expected_aa, TOL);
        assert_rotation_vector_near(&r.as_rotation_vector(), &expected_rv, TOL);
        assert_rotation_matrix_near(&r.as_rotation_matrix(), &expected_mat, TOL);

        // From AxisAngle -> Quaternion
        let r = Rotation::from(expected_aa);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);

        // From RotationVector -> Quaternion
        let r = Rotation::from(expected_rv);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);

        // From RotationMatrix -> Quaternion
        let r = Rotation::from(expected_mat);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);
    }

    #[test]
    fn scipy_random_1() {
        const TOL: f32 = 1e-05_f32;
        let expected_quat = Quaternion::new(
            -0.13341595232486725_f32, -0.8230997920036316_f32, 
            -0.549361526966095_f32, 0.05393311753869057_f32
        );
        let expected_aa = AxisAngle::new(
            0.8305245637893677_f32, 0.554317057132721_f32, 
            -0.0544196218252182_f32, 2.873962640762329_f32
        );
        let expected_rv = RotationVector::new(
            2.3868966102600098_f32, 1.5930864810943604_f32, 
            -0.15639996528625488_f32
        );
        let expected_mat = RotationMatrix([
            [0.3905862271785736_f32, 0.9187498688697815_f32, 0.057802509516477585_f32],
            [0.889967679977417_f32, -0.36080414056777954_f32, -0.2788868546485901_f32],
            [-0.23537187278270721_f32, 0.16037172079086304_f32, -0.9585828185081482_f32],
        ]);

        // From Quaternion -> all others
        let r = Rotation::from(expected_quat);
        assert_axis_angle_near(&r.as_axis_angle(), &expected_aa, TOL);
        assert_rotation_vector_near(&r.as_rotation_vector(), &expected_rv, TOL);
        assert_rotation_matrix_near(&r.as_rotation_matrix(), &expected_mat, TOL);

        // From AxisAngle -> Quaternion
        let r = Rotation::from(expected_aa);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);

        // From RotationVector -> Quaternion
        let r = Rotation::from(expected_rv);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);

        // From RotationMatrix -> Quaternion
        let r = Rotation::from(expected_mat);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);
    }

    #[test]
    fn scipy_random_2() {
        const TOL: f32 = 1e-05_f32;
        let expected_quat = Quaternion::new(
            0.5359283089637756_f32, -0.01157663855701685_f32, 
            -0.5877798199653625_f32, 0.605938732624054_f32
        );
        let expected_aa = AxisAngle::new(
            -0.013712114654481411_f32, -0.6962041854858398_f32, 
            0.7177128195762634_f32, 2.010378837585449_f32
        );
        let expected_rv = RotationVector::new(
            -0.027566546574234962_f32, -1.3996342420578003_f32, 
            1.4428746700286865_f32
        );
        let expected_mat = RotationMatrix([
            [-0.4252936840057373_f32, -0.6358703970909119_f32, -0.6440451145172119_f32],
            [0.6630884408950806_f32, 0.265408456325531_f32, -0.6999086141586304_f32],
            [0.615986168384552_f32, -0.724725604057312_f32, 0.3087618052959442_f32],
        ]);

        // From Quaternion -> all others
        let r = Rotation::from(expected_quat);
        assert_axis_angle_near(&r.as_axis_angle(), &expected_aa, TOL);
        assert_rotation_vector_near(&r.as_rotation_vector(), &expected_rv, TOL);
        assert_rotation_matrix_near(&r.as_rotation_matrix(), &expected_mat, TOL);

        // From AxisAngle -> Quaternion
        let r = Rotation::from(expected_aa);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);

        // From RotationVector -> Quaternion
        let r = Rotation::from(expected_rv);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);

        // From RotationMatrix -> Quaternion
        let r = Rotation::from(expected_mat);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);
    }

    #[test]
    fn scipy_random_3() {
        const TOL: f32 = 1e-05_f32;
        let expected_quat = Quaternion::new(
            -0.5751693248748779_f32, 0.044197794049978256_f32, 
            0.7545214295387268_f32, 0.3129284381866455_f32
        );
        let expected_aa = AxisAngle::new(
            -0.05402926355600357_f32, -0.922359049320221_f32, 
            -0.38253700733184814_f32, 1.9159703254699707_f32
        );
        let expected_rv = RotationVector::new(
            -0.10351847112178802_f32, -1.7672126293182373_f32, 
            -0.7329295873641968_f32
        );
        let expected_mat = RotationMatrix([
            [-0.3344535827636719_f32, 0.42667004466056824_f32, -0.8402937054634094_f32],
            [-0.2932772934436798_f32, 0.8002446889877319_f32, 0.5230648517608643_f32],
            [0.8956166505813599_f32, 0.4213799834251404_f32, -0.14251206815242767_f32],
        ]);

        // From Quaternion -> all others
        let r = Rotation::from(expected_quat);
        assert_axis_angle_near(&r.as_axis_angle(), &expected_aa, TOL);
        assert_rotation_vector_near(&r.as_rotation_vector(), &expected_rv, TOL);
        assert_rotation_matrix_near(&r.as_rotation_matrix(), &expected_mat, TOL);

        // From AxisAngle -> Quaternion
        let r = Rotation::from(expected_aa);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);

        // From RotationVector -> Quaternion
        let r = Rotation::from(expected_rv);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);

        // From RotationMatrix -> Quaternion
        let r = Rotation::from(expected_mat);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);
    }

    #[test]
    fn scipy_random_4() {
        const TOL: f32 = 1e-05_f32;
        let expected_quat = Quaternion::new(
            -0.03691032528877258_f32, 0.2726181745529175_f32, 
            -0.7089037895202637_f32, 0.6494400501251221_f32
        );
        let expected_aa = AxisAngle::new(
            -0.2728040814399719_f32, 0.7093871831893921_f32, 
            -0.6498828530311584_f32, 3.0677552223205566_f32
        );
        let expected_rv = RotationVector::new(
            -0.8368961215019226_f32, 2.1762261390686035_f32, 
            -1.99368155002594_f32
        );
        let expected_mat = RotationMatrix([
            [-0.848633885383606_f32, -0.3385780453681946_f32, 0.40643006563186646_f32],
            [-0.43446221947669983_f32, 0.007813927717506886_f32, -0.9006561636924744_f32],
            [0.301766574382782_f32, -0.9409058690071106_f32, -0.15373052656650543_f32],
        ]);

        // From Quaternion -> all others
        let r = Rotation::from(expected_quat);
        assert_axis_angle_near(&r.as_axis_angle(), &expected_aa, TOL);
        assert_rotation_vector_near(&r.as_rotation_vector(), &expected_rv, TOL);
        assert_rotation_matrix_near(&r.as_rotation_matrix(), &expected_mat, TOL);

        // From AxisAngle -> Quaternion
        let r = Rotation::from(expected_aa);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);

        // From RotationVector -> Quaternion
        let r = Rotation::from(expected_rv);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);

        // From RotationMatrix -> Quaternion
        let r = Rotation::from(expected_mat);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);
    }

    #[test]
    fn scipy_random_5() {
        const TOL: f32 = 1e-05_f32;
        let expected_quat = Quaternion::new(
            -0.10882557928562164_f32, -0.13018715381622314_f32, 
            -0.47953668236732483_f32, 0.8609604239463806_f32
        );
        let expected_aa = AxisAngle::new(
            0.1309649795293808_f32, 0.4824017286300659_f32, 
            -0.8661043643951416_f32, 2.9235095977783203_f32
        );
        let expected_rv = RotationVector::new(
            0.382877379655838_f32, 1.4103060960769653_f32, 
            -2.532064437866211_f32
        );
        let expected_mat = RotationMatrix([
            [-0.9424166083335876_f32, 0.3122480809688568_f32, -0.11980026960372925_f32],
            [-0.06253001093864441_f32, -0.5164031386375427_f32, -0.8540595769882202_f32],
            [-0.32854369282722473_f32, -0.7973887920379639_f32, 0.5061917901039124_f32],
        ]);

        // From Quaternion -> all others
        let r = Rotation::from(expected_quat);
        assert_axis_angle_near(&r.as_axis_angle(), &expected_aa, TOL);
        assert_rotation_vector_near(&r.as_rotation_vector(), &expected_rv, TOL);
        assert_rotation_matrix_near(&r.as_rotation_matrix(), &expected_mat, TOL);

        // From AxisAngle -> Quaternion
        let r = Rotation::from(expected_aa);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);

        // From RotationVector -> Quaternion
        let r = Rotation::from(expected_rv);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);

        // From RotationMatrix -> Quaternion
        let r = Rotation::from(expected_mat);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);
    }

    #[test]
    fn scipy_random_6() {
        const TOL: f32 = 1e-05_f32;
        let expected_quat = Quaternion::new(
            0.42938029766082764_f32, -0.503265917301178_f32, 
            -0.4137410521507263_f32, 0.6254392862319946_f32
        );
        let expected_aa = AxisAngle::new(
            -0.5572502017021179_f32, -0.458122193813324_f32, 
            0.6925289034843445_f32, 2.2539796829223633_f32
        );
        let expected_rv = RotationVector::new(
            -1.256030559539795_f32, -1.0325981378555298_f32, 
            1.5609461069107056_f32
        );
        let expected_mat = RotationMatrix([
            [-0.12471198290586472_f32, -0.12065912783145905_f32, -0.9848290681838989_f32],
            [0.9535461664199829_f32, -0.28890177607536316_f32, -0.08535490930080414_f32],
            [-0.2742200195789337_f32, -0.9497247934341431_f32, 0.1510835587978363_f32],
        ]);

        // From Quaternion -> all others
        let r = Rotation::from(expected_quat);
        assert_axis_angle_near(&r.as_axis_angle(), &expected_aa, TOL);
        assert_rotation_vector_near(&r.as_rotation_vector(), &expected_rv, TOL);
        assert_rotation_matrix_near(&r.as_rotation_matrix(), &expected_mat, TOL);

        // From AxisAngle -> Quaternion
        let r = Rotation::from(expected_aa);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);

        // From RotationVector -> Quaternion
        let r = Rotation::from(expected_rv);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);

        // From RotationMatrix -> Quaternion
        let r = Rotation::from(expected_mat);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);
    }

    #[test]
    fn scipy_random_7() {
        const TOL: f32 = 1e-05_f32;
        let expected_quat = Quaternion::new(
            -0.17982643842697144_f32, 0.1826217919588089_f32, 
            0.1906253546476364_f32, 0.9476147294044495_f32
        );
        let expected_aa = AxisAngle::new(
            -0.18564815819263458_f32, -0.19378435611724854_f32, 
            -0.963318407535553_f32, 2.779972553253174_f32
        );
        let expected_rv = RotationVector::new(
            -0.5160967707633972_f32, -0.5387151837348938_f32, 
            -2.6779987812042236_f32
        );
        let expected_mat = RotationMatrix([
            [-0.8686234951019287_f32, 0.41043704748153687_f32, 0.27755123376846313_f32],
            [-0.2711876928806305_f32, -0.8626488447189331_f32, 0.42695924639701843_f32],
            [0.4146691560745239_f32, 0.2955983579158783_f32, 0.8606225252151489_f32],
        ]);

        // From Quaternion -> all others
        let r = Rotation::from(expected_quat);
        assert_axis_angle_near(&r.as_axis_angle(), &expected_aa, TOL);
        assert_rotation_vector_near(&r.as_rotation_vector(), &expected_rv, TOL);
        assert_rotation_matrix_near(&r.as_rotation_matrix(), &expected_mat, TOL);

        // From AxisAngle -> Quaternion
        let r = Rotation::from(expected_aa);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);

        // From RotationVector -> Quaternion
        let r = Rotation::from(expected_rv);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);

        // From RotationMatrix -> Quaternion
        let r = Rotation::from(expected_mat);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);
    }

    #[test]
    fn scipy_random_8() {
        const TOL: f32 = 1e-05_f32;
        let expected_quat = Quaternion::new(
            0.7030544281005859_f32, -0.3189932405948639_f32, 
            -0.5067675709724426_f32, 0.3835940659046173_f32
        );
        let expected_aa = AxisAngle::new(
            -0.44856852293014526_f32, -0.7126169204711914_f32, 
            0.5394102334976196_f32, 1.5822254419326782_f32
        );
        let expected_rv = RotationVector::new(
            -0.7097365260124207_f32, -1.1275205612182617_f32, 
            0.8534685969352722_f32
        );
        let expected_mat = RotationMatrix([
            [0.19208447635173798_f32, -0.21606417000293732_f32, -0.957298219203949_f32],
            [0.8626858592033386_f32, 0.502197802066803_f32, 0.0597531720995903_f32],
            [0.46784254908561707_f32, -0.8373252749443054_f32, 0.2828599214553833_f32],
        ]);

        // From Quaternion -> all others
        let r = Rotation::from(expected_quat);
        assert_axis_angle_near(&r.as_axis_angle(), &expected_aa, TOL);
        assert_rotation_vector_near(&r.as_rotation_vector(), &expected_rv, TOL);
        assert_rotation_matrix_near(&r.as_rotation_matrix(), &expected_mat, TOL);

        // From AxisAngle -> Quaternion
        let r = Rotation::from(expected_aa);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);

        // From RotationVector -> Quaternion
        let r = Rotation::from(expected_rv);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);

        // From RotationMatrix -> Quaternion
        let r = Rotation::from(expected_mat);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);
    }

    #[test]
    fn scipy_random_9() {
        const TOL: f32 = 1e-05_f32;
        let expected_quat = Quaternion::new(
            0.4820016324520111_f32, -0.08441971987485886_f32, 
            -0.6224427819252014_f32, -0.6108295321464539_f32
        );
        let expected_aa = AxisAngle::new(
            -0.09635081142187119_f32, -0.7104129791259766_f32, 
            -0.6971584558486938_f32, 2.1357171535491943_f32
        );
        let expected_rv = RotationVector::new(
            -0.2057780772447586_f32, -1.5172412395477295_f32, 
            -1.4889332056045532_f32
        );
        let expected_mat = RotationMatrix([
            [-0.5210954546928406_f32, 0.6939345598220825_f32, -0.49690476059913635_f32],
            [-0.48374876379966736_f32, 0.23952119052410126_f32, 0.8417937755584717_f32],
            [0.7031689882278442_f32, 0.6790319681167603_f32, 0.21087656915187836_f32],
        ]);

        // From Quaternion -> all others
        let r = Rotation::from(expected_quat);
        assert_axis_angle_near(&r.as_axis_angle(), &expected_aa, TOL);
        assert_rotation_vector_near(&r.as_rotation_vector(), &expected_rv, TOL);
        assert_rotation_matrix_near(&r.as_rotation_matrix(), &expected_mat, TOL);

        // From AxisAngle -> Quaternion
        let r = Rotation::from(expected_aa);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);

        // From RotationVector -> Quaternion
        let r = Rotation::from(expected_rv);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);

        // From RotationMatrix -> Quaternion
        let r = Rotation::from(expected_mat);
        assert_quaternion_near(&r.as_quaternion(), &expected_quat, TOL);
    }
}

